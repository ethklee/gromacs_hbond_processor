"""
analysis.py

Core analysis functions for computing hydrogen bond statistics from gmx_hbond.

Includes functions to generate summary dataframes and hydrogen bond interaction maps
using '.ndx', '.gro', and '.xpm' files.

The creation of summary dataframes for an MD system is the backbone of this set of
analysis scripts. A dataframe made using hbond_df() will list all donor and acceptor
residues and atoms involved in hydrogen bonds, sorted by frequency.

Author: Ethan Lee
Created: 2021-06-19
"""

import numpy as np
import pandas as pd
from .utils import cut_occ, get_gro_data, make_donor_acceptor_columns
from .parser import hbond_ndx_import, gro_import, hbond_xpm_import

def hbond_df(ndx_file, gro_file, xpm_file, cutoff=10):
    """
    Create a DataFrame of hydrogen bond donor-acceptor pairs and their occupancies.

    This function parses GROMACS 'hbond' output files and builds a table of all
    hydrogen bonds with occupancy above a given threshold.

    Parameters
    ----------
    ndx_file : str
        Path to the '.ndx' file generated by 'gmx hbond'.
    gro_file : str
        Path to the corresponding '.gro' structure file.
    xpm_file : str
        Path to the '.xpm' file containing the hydrogen bond time series.
    cutoff : float, optional
        Minimum occupancy (%) for bonds to be included in the output (default is 10%).

    Returns
    -------
    pandas.DataFrame
        DataFrame with columns:
        - Donor : formatted donor atom label
        - Acceptor : formatted acceptor atom label
        - Occupancy (%) : rounded occupancy value
    """

    # Load indices of donors, hydrogens, and acceptor atoms
    ndx_data = np.array(hbond_ndx_import(ndx_file)[1][-1]).T

    # Load protein data
    gro_data = gro_import(gro_file)

    # Load hydrogen bond occupancies
    occupancy = np.around(np.flip(hbond_xpm_import(xpm_file)[2]), 2) # flip values because xpm file returns them backwards

    # Filter by occupancy cutoff
    occ_cut_indices = cut_occ(occupancy, cutoff=cutoff)
    filtered_occupancy = occupancy[occ_cut_indices]
    filtered_indices = [n[occ_cut_indices] for n in ndx_data]

    # Get donor, hydrogen, and acceptor data from gro file
    atom_props = [get_gro_data(atom_indices, gro_data) for atom_indices in filtered_indices]

    # Make donor and acceptor columns
    donor_labels, acceptor_labels = make_donor_acceptor_columns(atom_props)

    # Make dataframe
    df = pd.DataFrame({
        'Donor': donor_labels,
        'Acceptor': acceptor_labels,
        'Occupancy (%)': filtered_occupancy
    })

    return df.sort_values('Occupancy (%)', ascending=False).reset_index(drop=True)

def hbond_map(ndx_file, gro_file, xpm_file):
    """
    Generate a residue-level hydrogen bond map from GROMACS output.

    This function computes how frequently each pair of residues forms at least one 
    hydrogen bond over a trajectory, based on 'gmx hbond' output files.

    Parameters
    ----------
    ndx_file : str
        Path to the '.ndx' file from 'gmx hbond'.
    gro_file : str
        Path to the '.gro' structure file used for residue mapping.
    xpm_file : str
        Path to the '.xpm' file containing the H-bond time series.

    Returns
    -------
    tuple
        - hbond_matrix : numpy.ndarray
            Symmetric matrix (n_residues x n_residues) with H-bond frequencies in %.
        - residue_ids : list of int
            List of residue numbers (matching matrix row/column order).
    """
    
    # Get H-bond timeseries matrix from xpm file (shape: (n_hbonds, n_frames))
    # Each row is the timeseries of an H-bond: 1 means present, 0 means absent
    # Flip matrix because GROMACS makes it backwards for some reason
    matrix = np.flip(hbond_xpm_import(xpm_file)[1], axis=0)
    
    # Import gro data for atom and residue numbers
    gro_data = gro_import(gro_file)
    
    # Get H-bonds from ndx file
    ndx_data = np.array(hbond_ndx_import(ndx_file)[1][-1])

    # Remove second column (hydrogens) since residue numbers of hydrogens will be the same as the donors
    donors_acceptors_indices = np.delete(ndx_data, 1, axis=1).T

    # Replace atom indices with residue numbers
    donors_acceptors_residues = [get_gro_data(da, gro_data) for da in donors_acceptors_indices]
    donors = np.array(donors_acceptors_residues[0]).T[0]
    acceptors = np.array(donors_acceptors_residues[1]).T[0]
    das = np.array((donors.astype(int), acceptors.astype(int))).T.tolist()
    
    # Check for duplicate H-bonds, add duplicate matrix rows together
    unique_das = [] # save unique pairs of hbonds
    unique_matrix = []
    for i, pair in enumerate(das):
        if pair in unique_das:
            j = unique_das.index(pair)
            unique_matrix[j] = unique_matrix[j] + matrix[i]

        # Check for reverse H-bonds that are the same, consider them duplicates
        else:
            reverse_pair = pair[:]
            reverse_pair.reverse()
            if reverse_pair in unique_das:
                j = unique_das.index(reverse_pair)
                unique_matrix[j] = unique_matrix[j] + matrix[i]
            else:
                unique_das.append(pair)
                unique_matrix.append(matrix[i])

    unique_matrix = np.array(unique_matrix)    
    
    # Compute lifetime of each H-bond
    nframes = unique_matrix.shape[1]
    occ = np.count_nonzero(unique_matrix, axis=1)/nframes*100
    
    # Make final H-bond matrix
    residues = np.unique(np.array(gro_data).T[0].astype(int)).tolist()
    nres = len(residues)
    hbond_matrix = np.zeros((nres, nres))
    hbond_matrix_mirrored = np.zeros((nres, nres))
    
    # Sort the residue numbers in each pair so that the lower residue number comes first, then flip matrix
    unique_das_sorted = []
    for pair in unique_das:
        if pair[0] <= pair[1]:
            unique_das_sorted.append(pair)
        else:
            unique_das_sorted.append([pair[1], pair[0]])

    for i, pair in enumerate(unique_das_sorted):
        res1 = residues.index(pair[0])
        res2 = residues.index(pair[1])
        hbond_matrix[res1, res2] = occ[i]
    
    hbond_matrix_mirrored = hbond_matrix + hbond_matrix.T
    
    return hbond_matrix_mirrored, residues